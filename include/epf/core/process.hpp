#ifndef PROCESS_MODEL_HPP_
#define PROCESS_MODEL_HPP_

#include "epf/core/enum.hpp"
#include "epf/core/state.hpp"
#include "epf/util/exceptions.hpp"
#include "epf/util/traits.hpp"
#include <Eigen/Dense>
#include <algorithm>
#include <array>
#include <cmath>
#include <random>
#include <type_traits>

namespace epf {

// I should use partial class specialization...
template <typename State, typename T = void>
struct Predict {
  using StateVector = typename StateTraits<State>::ArithmeticType;

  /**
   *  @brief  This function propagates state according to state transition model, notice that this function only takes
   *          x_{k-1}, without input, u_{k-1}. Due to the fact that particle filter has no idea how to obtain
   *          the input, user should do it on their own in this function. Also, noise, v_{k-1}, is not passed as well
   *          since particle filter has no idea how a process model its noise, could be normal gausian rv, or gamma rv,
   *          etc.
   *
   *  @param  t_prev_state  Previous state
   */
  virtual Prediction predict(std::vector<StateVector>& /* t_prev_state */) = 0;

  Predict()                          = default;
  Predict(Predict const&)            = default;
  Predict& operator=(Predict const&) = default;

  Predict(Predict&&) noexcept            = default;
  Predict& operator=(Predict&&) noexcept = default;

  virtual ~Predict() = default;
};

template <typename State>
struct Predict<State, std::enable_if_t<satisfy_noise_traits<State>::value>> {
  using StateVector         = typename StateTraits<State>::ArithmeticType;
  using StateNoiseVector    = typename NoiseTraits<State>::ArithmeticType;
  using NoiseCovarianceType = typename NoiseTraits<State>::NoiseCovType;

  virtual Prediction predict(std::vector<StateVector>& /* t_prev_state */) {
    throw NotImplementedError{"The algorithm requires this function, but user didn't provide one"};
  }

  /**
   *  @brief  This function propagates state according to state transition model, the only difference between this one
   *          and the previous one is the noise parameter. This can be useful for certain algorithm that takes noise
   *          into consideration, such as unscented particle filter, see [1] for more detail.
   *
   *  [1] Rudolph van der Merwe, Arnaud Doucet, Nando de Freitas, Eric Wan. August 16, 2000, THE UNSCENTED PARTICLE
   *      FILTER
   *
   *  @param  t_prev_state  Previous state
   *  @param  t_artificial_noise  Noise generated by the algorithm
   *
   *  @todo   this should be pure virtual function (?)
   */
  virtual Prediction predict(std::vector<StateVector>& /* t_prev_state */,
                             std::vector<StateNoiseVector> const& /* t_artificial_noise */) = 0;

  [[nodiscard]] NoiseCovarianceType get_noise_covariance() const noexcept { return this->noise_cov_; }
  void set_noise_covariance(NoiseCovarianceType const& t_noise_cov) noexcept { this->noise_cov_ = t_noise_cov; }

  Predict()                          = default;
  Predict(Predict const&)            = default;
  Predict& operator=(Predict const&) = default;

  Predict(Predict&&) noexcept            = default;
  Predict& operator=(Predict&&) noexcept = default;

  virtual ~Predict() = default;

 private:
  NoiseCovarianceType noise_cov_{};
};

/**
 *  @brief  Abstract interface for process model, a process model encodes prior knowledge on how state evolved over
 *          time. Formalized by mathematical model x_{k} = f_{k}(x_{k-1}, u_{k-1}, v_{k-1}), where x_{k} represents
 *          state at descrete time step k, u_{k-1}, v_{k-1} represents optional inputs, and i.i.d. noise, respectively
 *
 *  @tparam State state to predict
 */
template <typename State>
struct ProcessModel : public Predict<State> {
  using StateVector    = typename StateTraits<State>::ArithmeticType;
  using CovarianceType = typename StateTraits<State>::CovarianceType;

  using Predict<State>::predict;

  /**
   * @brief This function checks whether the input is ready for the process model. Some process model requires sensor
   *        input, such as wheel encoder for kinemetics, in that case, if encoders aren't ready (though normally
   *        impossible, since the update rate of the encoder should be way faster than particle filter), or ready but
   *        the values doesn't change much, return false here to tell the particle filter to skip sampling and
   *        resampling this time.
   *
   * @return true if input is ready, false otherwise
   */
  virtual bool input_ready() { return true; }

  /**
   *  @brief  This function calculate the probability to reach to current state given previous state, and input, i.e.
   *          p(x_{t}|x_{t-1},u_{t}). As mentioned above, user should obtain the input on their own. This might be
   *          needed if one chooses different propotional distribution as default one, i.e. p(x_{t}|x_{t-1},u_{t})
   */
  [[nodiscard]] virtual double calculate_probability(StateVector const& /* t_curr */, StateVector const& /* t_prev */) {
    throw NotImplementedError{"The algorithm require this function, but user didn't provide one"};
  }

  [[nodiscard]] CovarianceType get_process_covariance() const noexcept { return this->proc_cov_; }
  void set_process_covariance(CovarianceType const& t_cov) noexcept { this->proc_cov_ = t_cov; }

  ProcessModel()                               = default;
  ProcessModel(ProcessModel const&)            = default;
  ProcessModel& operator=(ProcessModel const&) = default;

  ProcessModel(ProcessModel&&) noexcept            = default;
  ProcessModel& operator=(ProcessModel&&) noexcept = default;

  virtual ~ProcessModel() = default;

 private:
  CovarianceType proc_cov_{};
};

}  // namespace epf

#endif